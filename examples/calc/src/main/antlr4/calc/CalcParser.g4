parser grammar CalcParser;

options {
    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    tokenVocab = CalcLexer;
}

// Toplevel rule: matches an expression followed by the end of file
// (EOF). The "returns" declaration says which Java type is produced
// by this rule.
expr returns[AbstractExpr tree]
    : sum_expr EOF {
                    // between braces ({}), an action for this rule,
                    // i.e. a piece of Java code that will be executed
                    // while matching the rule. Must assign a value to
                    // $tree to produce the value declared in the
                    // returns clause above.
                    $tree = $sum_expr.tree;
            }
    ;

sum_expr returns [AbstractExpr tree]
    : e=mult_expr {
            $tree = $e.tree; 
        }
      (PLUS e2=mult_expr {
            // action inside (expr)* => will be executed once for each
            // match of "expr".
            $tree = new Plus($tree, $e2.tree);
        }
      | MINUS e2=mult_expr {
            $tree = new Minus($tree, $e2.tree);
        }
      )*
    ;

mult_expr returns [AbstractExpr tree]
    : e=literal {
            $tree = $e.tree;
        }
      (TIMES e2=literal {
            $tree = new Times($tree, $e2.tree);
        }
      )*
    ;

literal returns[IntLiteral tree]
    : INT {
            try {
                $tree = new IntLiteral(Integer.parseInt($INT.text));
            } catch (NumberFormatException e) {
                // The integer could not be parsed (probably it's too large).
                // set $tree to null, and then fail with the semantic predicate
                // {$tree != null}?. In decac, we'll have a more advanced error
                // management.
                $tree = null;
            }
        } {$tree != null}?
    ;
